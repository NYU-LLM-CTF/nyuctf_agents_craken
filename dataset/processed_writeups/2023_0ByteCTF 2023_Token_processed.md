# Token
> Decrypt the token

## About the Challenge
The provided program is a Python script that implements a cryptographic game. In this game, the program generates a series of random tokens, and the player has to input the correct token to win the game. These tokens are generated by randomly choosing characters from the set `0123456789abcdef` for a length of 32 characters.

Each time the player enters the correct token, the program generates two random prime numbers, calculates the modulus of the multiplication of these two numbers, and uses a fixed exponent (0x10001 or 65537) to perform encryption operations on the token. The encrypted token and its cryptographic parameters are printed, and the player needs to input the corresponding token. If the player correctly inputs the token 100 times, the flag will be printed. However, if the player makes even one incorrect attempt, the program will end.

```python
#!/usr/bin/env python3

from sympy import nextprime
from Crypto.Util.number import *
from random import choice
from flag import flag


def get_prime(n):
	r = getRandomInteger(n)
	p = nextprime(r)
	q = nextprime(r + getRandomInteger(32))
	return p, q

def get_token(l):
	return ''.join(choice('0123456789abcdef') for i in range(l))


correct = 0
while correct < 100:
	token = get_token(32)
	p, q = get_prime(256)
	n = p * q
	e = 0x10001
	m = bytes_to_long(token.encode())
	c = pow(m,e,n)

	print(f'[*] {n = }')
	print(f'[*] {e = }')
	print(f'[*] {c = }')

	answer = input("[TOKEN]> ")
	if answer == token:
		correct += 1
		print()
	else:
		exit(0)

print(flag)
```

## How to Solve?
Since this is an RSA challenge, I will use `RsaCtfTool`, which can be accessed in this repository: https://github.com/RsaCtfTool/RsaCtfTool. The command I used is as follows, taking one of the sample outputs from the server.

```bash
python3 RsaCtfTool.py -n 7269896398942751313404998468295986128862222329376625697025973239308668324343236405631631699065470706683897767391236403789451011065655516118499702813482523 -e 65537 --uncipher 3792027385448390677301120427312148659896623308858159996054213078559387591588782223572434360836211851421167883252676191360621136176901652226598967453688583
```


[Image extracted text: {
Testing
Itmp/tmptv32mq3h
Performing SQUFOF attack
Itmp/tmptv32mq3h
[t]
Attack success with SQUFOF method
Results
for /tmp/tmptv32mq3h:
Unciphered
data
HEX
Oxooooooooooooooooooooooooooooooooooooooooooooooooc
0000000000000003938613535323337343264326438356164363061613332306163323637333238
INT (big endian)
25881446708748788269168193531495573675803541344089059083215764148094514704952
INT (little endian)
294322826023075578345463011147730676128940941983875931318375382541060485948035989172613511828822021158776345663183
utf-
98a5523742d2d85ad60aa320ac267328
utf-16
0amR00#6#09
#J ~, #
Key]


This attack succeeded using the SQUFOF (Shanks's Square Forms Factorization) technique. The token seems to be in the UTF-8 section, and due to the 100 attempts on this server, it's impossible to do this manually. Hence, a Python script was created to automate this process. Some functions were taken from RsaCtfTool, such as `gcd`, `isqrt`, and the `SQUFOF` function itself. After obtaining the prime values p and q as a result of the SQUFOF function, decryption was performed on the ciphertext.

```python
from pwn import *
from Crypto.Util.number import inverse, long_to_bytes
import re

def gcd(a, b):
    while b:
        a, b = b, a % b
    return abs(a)

def isqrt(n):
    if n == 0:
        return 0
    x, y = n, (n + 1) >> 1
    while y < x:
        x, y = y, (y + n // y) >> 1
    return x

multiplier = [
    1,
    3,
    5,
    7,
    11,
    3 * 5,
    3 * 7,
    3 * 11,
    5 * 7,
    5 * 11,
    7 * 11,
    3 * 5 * 7,
    3 * 5 * 11,
    3 * 7 * 11,
    5 * 7 * 11,
    3 * 5 * 7 * 11,
]

def SQUFOF(N):
    s = isqrt(N)
    L = isqrt(s << 1) << 1
    B = 3 * L

    for k in range(0, len(multiplier)):
        D = multiplier[k] * N
        Po = Pprev = P = isqrt(D)
        Qprev = 1
        Q = D - (Po * Po)
        for i in range(2, B + 1):
            b = (Po + P) // Q
            P = b * Q - P
            q = Q
            Q = Qprev + b * (Pprev - P)
            r = isqrt(Q)
            if not (i & 1) and (r * r) == Q: break
            Pprev, Qprev = P, q
        b = (Po - P) // r
        Pprev = P = b * r + P
        Qprev = r
        Q = (D - (Pprev * Pprev)) // Qprev
        c1 = True
        while c1:
            b = (Po + P) // Q
            Pprev = P
            P = b * Q - P
            q = Q
            Q = Qprev + b * (Pprev - P)
            Qprev = q
            c1 = (P != Pprev)
        r = gcd(N, Qprev)
        if 1 < r < N:
            return r, N // r
    return None

def decrypt(n,e,c):
    p,q = SQUFOF(n)
 
    phi = (p-1)*(q-1)
 
    d = inverse(e, phi)
 
    m = pow(c,d,n)
 
    return m

p = remote('0x7e7ctf.zerobyte.me', 10021)
while True:
    n = p.recvline()
    print(n)
    equal_sign_index = n.index(b'=')
    n = n[equal_sign_index + 2:].strip()
    n = int(n.decode('utf-8'))

    e = p.recvline()
    equal_sign_index = e.index(b'=')
    e = e[equal_sign_index + 2:].strip()
    e = int(e.decode('utf-8'))

    c = p.recvline()
    equal_sign_index = c.index(b'=')
    c = c[equal_sign_index + 2:].strip()
    c = int(c.decode('utf-8'))

    m = decrypt(n,e,c)

    print(long_to_bytes(m))

    p.sendlineafter("[TOKEN]> ", long_to_bytes(m))
    p.recvline()
```


[Image extracted text: 622a03a9680f19719e739ab81f474e16 '
6266505994365848388383526549632637939350809881035575803976609834394462797216101365809541739432174325740283016973898542775158089926399794191887297157402971 n
Scbel455sfazdiclaecl47ed5d75e041
151440230336058288044626268388672933912594508805647161771364180910219977584538656088430620121744457665154506163407528468381213160265329033276887319358291 n
8852d99fe2073c794e59aa9c8e957afle
440783608283219235727245810154575140349332248380666263877229414033896543527681989315082799377155257782665865764940225808098973777075252620696907809309343 n
332688113ec24cead3102d454408024f
70549a3377da35661n615787760n71n31073au]0776ar57o1ag837
3030
79g81nnbggb6oudbbudgisuu51aag9qu9rios
Js500
7907ob8z3
5zo79iuoaisiosgegeoiungaion
JC5cc40 4batag 9bsbba8,a78615c05
121607332829811830980509614589430489492495067570247364772875602030769779770644779372245389882578824
EEeleecEene
1061655461977384984580801158431654111n
1f04306054c20117590113006878c3b0
1044716027032994708829634386010518941996556787539785820460302381993841816079232046871201181476012915180598888028994875146332334915184363178338647251264833n'
Caf67nfc34u8779ac9d161137bc07037
117210617293350945484450640671059263103816362623469977274907277698980259452293190520456282413034980159780556637632748067885573150406215327874744904450946231n
cf17083604c77d6502731c6c035d3ccc
ObyteCTf {enang
Dollet
sedekat_ini_dek?}]


```
0byteCTF{emang_boleh_sedekat_ini_dek?}
```